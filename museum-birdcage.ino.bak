#define RESET_TIME 180000 // 3 minutes

#define CMD_SEL_DEV 0X09
#define DEV_TF 0X02

#define TRACK_FULL 6
#define TRACK_FAILED 7
#define TRACK_WINNING 8


bool SOLVED = false;
bool SOLVED_TRAY_IN = false;
unsigned long solved_at = 0;
bool TRAY_OUT = false;
bool ENABLED = true;

bool PLAYING_SONG = false;
unsigned long playing_song_at = 0;

static int8_t Send_buf[8] = {0};

void setup() {
  Serial1.begin(9600, SERIAL_8N1, 16, 17);
  delay(500);//Wait chip initialization is complete
  sendCommand(CMD_SEL_DEV, DEV_TF);//select the TF card
  delay(200);
}

void sendCommand(int8_t command, int16_t dat)
{
  delay(20);
  Send_buf[0] = 0x7e; //starting byte
  Send_buf[1] = 0xff; //version
  Send_buf[2] = 0x06; //the number of bytes of the command without starting byte and ending byte
  Send_buf[3] = command; //
  Send_buf[4] = 0x00;//0x00 = no feedback, 0x01 = feedback
  Send_buf[5] = (int8_t)(dat >> 8);//datah
  Send_buf[6] = (int8_t)(dat); //datal
  Send_buf[7] = 0xef; //ending byte
  for(uint8_t i=0; i<8; i++)//
  {
    Serial1.write(Send_buf[i]) ;
  }
}

void playTrack(int8_t track, bool loud)
{
  // loud=60%, soft=22%
  sendCommand(06, loud ? 0x3C : 0x16);
  
  delay(20);
  Send_buf[0] = 0x7e; //starting byte
  Send_buf[1] = 0xff; //version
  Send_buf[2] = 0x06; //the number of bytes of the command without starting byte and ending byte
  Send_buf[3] = 0x0F; //
  Send_buf[4] = 0x00;//0x00 = no feedback, 0x01 = feedback
  Send_buf[5] = 0x01;
  Send_buf[6] = track; 
  Send_buf[7] = 0xef; //ending byte
  for(uint8_t i=0; i<8; i++)//
  {
    Serial1.write(Send_buf[i]);
  }
}

void reset() {
  solved_at = 0;
  SOLVED = false;
  SOLVED_TRAY_IN = false;
  TRAY_OUT = false;
  ENABLED = true;
}

void loop() {

  // if its not enabled, then NOOP
  if (!ENABLED) {
    if (PLAYING_SONG) {
      Serial.printf("Stopping song since its disabled\n");
      sendCommand(0x16,0x00);
      PLAYING_SONG = false;
      playing_song_at = 0;
    }
    return;
  }

  if (SOLVED) {
    if (!TRAY_OUT) {
      playTrack(TRACK_WINNING, false);
      digitalWrite(MOTOR_ENABLE_PIN, LOW);
      stepper.rotate(MOTOR_TRAVEL);
      digitalWrite(MOTOR_ENABLE_PIN, HIGH);
      TRAY_OUT = true;
    } else if (!SOLVED_TRAY_IN && millis() - solved_at > RESET_TIME) {
      Serial.printf("Resetting tray...\n");
      digitalWrite(MOTOR_ENABLE_PIN, LOW);
      stepper.rotate(-MOTOR_TRAVEL);
      digitalWrite(MOTOR_ENABLE_PIN, HIGH);
      ENABLED = false;
      SOLVED_TRAY_IN = true;
    }

    // NOOP the rest if we've solved it
    return;
  }

  if (!PLAYING_SONG) {
    if (last_button_press == 0 || millis() - last_button_press > BUTTON_TIME_BETWEEN_SONG) {
      Serial.printf("playing song...\n");
      PLAYING_SONG = true;
      playing_song_at = millis();
      playTrack(TRACK_FULL, true);
    }
  } else {

    // if totally timed out, restart it
    if (millis() - playing_song_at > 25000) {
      Serial.printf("done with song, starting again...\n");    
      PLAYING_SONG = false;
      playing_song_at = 0;
    }

    // if there was a button press between our start time, then restart it
    if (last_button_press > 0 && millis() - last_button_press > BUTTON_TIME_BETWEEN_SONG && last_button_press - playing_song_at < 25000) {
      Serial.printf("restarting song from button press...\n");    
      PLAYING_SONG = false;
      playing_song_at = 0;
    }
  }
}
